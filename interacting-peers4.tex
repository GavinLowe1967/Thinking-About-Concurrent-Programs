\section{Building a spanning tree}

Suppose we have a collection of nodes in a graph.  Some, but not necessarily
all, pairs of nodes are directly connected: there are channels between the two
nodes in each direction.  It might be that the graph is disconnected: it might
not be possible to find a path from one node to another.  

One of the nodes is designated as a controller.  We want to find which other
nodes are reachable from the controller, and to find a spanning tree for them,
i.e.~a collection of edges that connect those nodes, without any cycles.  This
spanning tree could be used subsequently to distribute messages.

The idea of the protocol is as follows.  Initially, node~|0| sends a message
|Start(0)| to each of its neighbours.  For each such neighbour~|n|, if this is
the first |Start| message it has seen, then the edge from~|0| to~|n| will be
included in the spanning tree.  In this case, node~|n| tries to continue the
tree by sending a message |Start(n)| to each of its neighbours, except~|0|,
which react in a similar way.  However, if a node receives two or more |Start|
messages, it sends a reply |No| to all except the first, so the corresponding
edge will not be part of the spanning tree.  

Suppose node~|p| sends a |Start| message to node~|n|, and this is node |n|'s
first |Start| message, then |n| will eventually return to~|p| a message of the
form |Finished(edges)|, where |edges| represents a tree, starting with an edge
from~|p| to~|n|, and maybe including subsequent nodes from there.  Node~|p|
can accumulate the edges from all such messages it receives, and return the
result to its predecessor in the spanning tree. 


\begin{figure}
\begin{scala}
import scala.collection.mutable.ArrayBuffer

/** adjacency should be symmetric and irreflexive. */ 
class SpanningTree(n: Int, adjacency: Array[Array[Boolean]]){
  require(adjacency.length == n && adjacency.forall(_.length == n))

  private type NodeId = Int
  private type Edge = (NodeId,NodeId)

  private trait Msg
  /** A message from `prev` telling the recipient to start exploration. */
  private case class Start(prev: NodeId) extends Msg
  /** A message indicating that the sender has constructed a subtree using
    * `edges`. */
  private case class Finished(edges: List[Edge]) extends Msg
  /** Message indicating that the relevant edge should not be included. */
  private case object No extends Msg

  private var result: List[Edge] = null

  private val chans = Array.ofDim[BuffChanT[Msg]](n,n)

  private val verbose = false 

  private def node(me: Int, ins: Array[??[Msg]], outs: Array[!![Msg]]) = ...

  def apply(): List[Edge] = ...
}
\end{scala}
\caption{Outline of the spanning tree code.}
\label{fig:spanning-tree}
\end{figure}

%%%%%%%%%%

A node with identity `me`.  The channels in `ins` and `outs` connect this
node with its neighbours, with `ins(i)` and `outs(i)` connecting to the
same neighbour. 

\begin{figure}
\begin{scala}
  private def node(me: Int, ins: Array[??[Msg]], outs: Array[!![Msg]]) 
  = thread(s"node($me)"){
    val size = ins.length; require(outs.length == size); var edges = List[Edge]()
    if(size != 0){
      // Identity of this node's predecessor, and its index in the arrays.
      var prev = -1; var pIx = -1; var terminated = false
      // Waiting phase
      if(me != 0) attempt{
        alt(| ( 
          for(i <- 0 until size)
          yield ins(i) =?=> { case Start(p) => prev = p; pIx = i }
        ) )
      }{ terminated = true }
      if(!terminated){
        // Sending phase
        for(i <- 0 until size; if i != pIx) outs(i)!Start(me)
        // Receiving phase
        val pendingIn = Array.fill(size)(true); if(pIx >= 0) pendingIn(pIx) = false
        serve(| (
          for(i <- 0 until size)
          yield pendingIn(i) && ins(i) =?=> { m =>
            m match{
              case Finished(es) => edges = es++edges
              case Start(_) => outs(i)!No
              case No =>
            }
            pendingIn(i) = false
          }
        ) ) // end of serve
        // Finishing phase
        if(pIx >= 0) outs(pIx)!Finished((prev,me)::edges)
      } // end of if(!terminated)
    } // end of if(ins.nonEmpty)
    if(me == 0){
      result = edges
      for(i <- 0 until n; j <- 0 until n){
        val c = chans(i)(j); if(c != null) c.close()
      }
    } 
  }
\end{scala}
\caption{A node in the spanning tree example.}
\label{fig:spanning-tree-node}
\end{figure}

%%%%%%%%%%

\begin{figure}
\begin{scala}
  import scala.collection.mutable.ArrayBuffer

  def apply(): List[Edge] = {
    // Initialise channels
    // chans(i)(j) is from i to j
    for(i <- 0 until n; j <- 0 until n; if adjacency(i)(j)){
      assert(i != j && adjacency(j)(i))
      chans(i)(j) = new BuffChan[Msg](2)
    }
    // In-ports for node i.
    def mkIns(i: NodeId): Array[??[Msg]] = {
      val ins1 = new ArrayBuffer[??[Msg]]
      for(j <- 0 until n; if adjacency(i)(j)) ins1 += chans(j)(i)
      ins1.toArray
    }
    // Out-ports for node i.
    def mkOuts(i: NodeId): Array[!![Msg]] = {
      val outs1 = new ArrayBuffer[!![Msg]]
      for(j <- 0 until n; if adjacency(i)(j)) outs1 += chans(i)(j)
      outs1.toArray
    }
    run(|| (for(i <- 0 until n) yield node(i, mkIns(i), mkOuts(i))))
    result
  }
\end{scala}
\caption{The main code for the spanning tree example.}
\label{fig:spanning-tree-apply}
\end{figure}

%%%%%%%%%%

\begin{figure}
\begin{scala}
  def doTest = {
    val n = 5+Random.nextInt(5)
    val adjacency = Array.ofDim[Boolean](n,n)
    for(i <- 0 until n; j <- 0 until i; if Random.nextDouble() <= 0.3){ 
      adjacency(i)(j) = true; adjacency(j)(i) = true 
    }
    // println(adjacency.map(_.mkString(", ")).mkString("\n"))
    val tree = new SpanningTree(n, adjacency)()

    // Check adjacency and result compatible
    def errMsg = adjacency.map(_.mkString(", ")).mkString("\n")+"\n"+tree
    // Nodes reached by the tree
    val reached = new Array[Boolean](n); reached(0) = true
    for((a,b) <- tree){
      assert(reached(a), s"Unreached source of edge: ($a, $b)\n"+errMsg)
      assert(adjacency(a)(b), s"Non-edge used: ($a, $b)\n"+errMsg) 
      reached(b) = true
    }
    // Count number reached
    var numReached = 0; for(i <- 0 until n; if reached(i)) numReached += 1
    // Does `tree` have the right length to be a tree?
    assert(numReached == tree.length + 1, s"Not a tree.\n"+errMsg)
    // Check no other node should have been reached.
    for(i <- 0 until n; if !reached(i); j <- 0 until n)
      assert(!(reached(j) && adjacency(i)(j)), s"$i not reached:\n"+errMsg)
  }
\end{scala}
\caption{Testing the spanning code example.}
\label{fig:spanning-tree-test}
\end{figure}
