\section{Alts with out-ports}

So far, we have only seen alts that provide a choice between in-ports.
However, it is also possible to use an out-port in an alt, using the following
syntax:%
%
\begin{scala}
  bool && out =!=> { expression }
\end{scala}
%
If the (optional) boolean guard |bool| is true, when the out-port |out| is
ready for communication, the |expression| is evaluated and the result sent.

Sometimes it's necessary to do something \emph{after} the value has been sent,
using a continuation, with the following syntax.
%
\begin{scala}
   bool && outport =!=> { expression } ==> { command }
\end{scala}

For example, here's another definition for the |tee| function, which produces
a thread that inputs on one in-port, and outputs on two out-ports, in either
order. 
%
\begin{mysamepage}
\begin{scala}
def tee[T](in: ??[T], out1: !![T], out2: !![T]) = thread{
  repeat{ 
    val v = in?()
    alt( out1 =!=> { v } ==> { out2!v }
       | out2 =!=> { v } ==> { out1!v }
    )
  }
}
\end{scala}
%
This sends~|v| on whichever out-port is ready first, and then sends~|v| on the
other out-port.
\end{mysamepage}

%%%%%% A two-place buffer

Inports and outports can be mixed within an \SCALA{alt}.
%
The following code copies data from |in| to |out|, and can hold up to two
pieces of data at a time: it is a two-place buffer. 
%
\begin{scala}  
  /** Two place buffer. */
  def buff2[T](in: ??[T], out: !![T]): Unit = {
    val x = in?(); buff2A(in, out, x)
  }
  /** Two place buffer holding £x£. */
  def buff2A[T](in: ??[T], out: !![T], x: T): Unit = {
    alt(
      out =!=> { x } ==> { buff2(in, out) }
      | in =?=> { y => out!x; buff2A(in, out, y) }
    )
  }  
\end{scala}
%
Note how when it is holding a value~|x|, it can either output~|x|, or input a
new value~|y|, at which point it is full so must output~|x|, after which it is
just holding~|y|.


Here's an alternative definition.  The variable \SCALA{empty} records whether
the buffer is empty.  When $\sm{empty} = \sm{false}$,\, \SCALA{x} stores the
next value to be output.
%
\begin{scala}
  def buff2Alt[T](in: ??[T], out: !![T]) = {
    var x: T = null.asInstanceOf[T]  // Contents, possibly invalid.
    var empty = true // Is the buffer empty?
    serve(
      !empty && out =!=> { empty = true; x }
      | empty && in =?=> { v => x = v; empty = false }
      | !empty && in =?=> { v => out!x; x = v }
    )
  }
\end{scala}
%
In the first branch, the code \SCALA{\{ empty = true; x \}} is an expression
whose value is~|x|, but which has the side effect of setting |empty| to |true|. 
The last two branches could be merged, and an \SCALA{if} statement used. 
%
\begin{scala}
    | in =?=> { v => if(empty){ x = v; empty = false } else { out!x; x = v } }
\end{scala}


\framebox{Quicksort}
