At present, we can write threads that try to send or receive on a
\emph{single} channel.  However, it's often useful to be able to try to send
or receive on either of two or more channels: the \emph{alternation}, or
\emph{alt}, construct does that for us.
%
We will start by describing the basic syntax of alternation, and then use it
in examples.

%%%%%

We start by describing how a thread can try to receive from any one of several
different in-ports.  The construct
%
\begin{scala}
  alt( 
    in£$_1$£ =?=> {f£$_1$£}
    | ...
    | in£$_n$£ =?=> {f£$_n$£}
  )
\end{scala}
%
waits until one of the in-ports \SCALA{in}$_1$, \ldots, \SCALA{in}$_n$
is ready to communicate, reads a value~$v$ from the port, and applies the
relevant function |f|$_i$ to~$v$.  If |in|$_i$ is an in-port passing data
of type~|A|, then $\sm f_i$ must be a function that takes an argument of
type~|A|. 

Here's a very simple example.  (The notation |x => c| represents a function
that, given argument~|x|, performs~|c|.)
%
\begin{scala}
  alt(
    c1 =?=> { x => println(s"$x received on c1") }
    | c2 =?=> { x => println(s"$x received on c2") }
  )
\end{scala}

%%%%%

The following thread repeatedly inputs from one of two input ports, tags the
value input, and outputs it.
%
\begin{mysamepage}
%  def tagger[T](l: ??[T], r: ??[T], out: !![(Int, T)]) = thread{
\begin{scala}
  repeat{
    alt ( l =?=> { x => out!(0, x) }
        | r =?=> { x => out!(1, x) }
    )
  }
\end{scala}
\end{mysamepage}
%
Exercise: design a corresponding de-tagger.  \framebox{??}

%%%%% \heading{Guards}

It's sometimes useful to specify that a particular in-port should be
considered only if some condition, or \emph{guard}, is true.  In the construct
%
\begin{scala}
  alt( guard£$_1$£ && in£$_1$£ =?=> {f£$_1$£}
     | ...
     | guard£$_n$£ && in£$_n$£ =?=> {f£$_n$£}
  )
\end{scala}
%
a communication on each |in|$_i$ is possible only if the corresponding
|guard|$_i$ is true.  Thus, \SCALA{in =?=> ...} is equivalent to \SCALA{true
  && in =?=> ...}.  Each guard is evaluated once, and should not have side
effects.

If a guard evaluates to true and the inport is open, we say that the
corresponding branch is \emph{feasible}.  If no branch is feasible, the alt
throws an |AltAbort| exception (a subclass of \SCALA{Stopped}): this
corresponds to the case where the alt will never be able to communicate.

If a branch is feasible and the inport is available for communication, then we
say that the branch is \emph{ready}.
%
The alt waits until a branch is ready, and receives from the inport.  If
several are ready, it chooses between them.  If all the branches become
infeasible (because of channels being closed), the alt throws an |AltAbort|
exception.

%%%%% \heading{\scalashape serve}

It is very common to use an \SCALA{alt} inside a \SCALA{repeat}.  Consider the
construct
%
\begin{scala}
  repeat{ 
    alt( g£$_1$£ && in£$_1$£ =?=> {f£$_1$£} | ... | g£$_n$£ && in£$_n$£ =?=> {f£$_n$£} ) 
  }
\end{scala}
%
Suppose no branch of the alt is feasible, that is, for every branch, either
the guard is false or the port is closed.  Then the alt will throw an
|AltAbort| exception, which the |repeat| will catch.  Thus the above construct
will repeatedly execute the alt until all branches become infeasible, at which
point it terminates cleanly.  

% (or one of the |f|$_i$ throws a |Stopped| exception).

Note that the above construct evaluates each guard expression~|g|$_i$ and each
port expression |in|$_i$ on each iteration.

%%%%% \heading{\scalashape serve}

The construct 
%
\begin{scala}
  serve( g£$_1$£ && in£$_1$£ =?=> {f£$_1$£} | ... | g£$_n$£ && in£$_n$£ =?=> {f£$_n$£} )
\end{scala}
%
is very similar to the previous |repeat{ alt(...) }| construct, but with two
differences.

One difference is that the earlier construct creates a new alternation object
(from a class |Alt|) on each iteration, whereas the |serve| creates a single
alternation object which is used repeatedly.

%%%%% \heading{Fairness}

The implementation of an alt tests whether its branches are ready in the order
given.  In the |repeat{alt(...)}| construct, a new alt object is created
for each iteration, so if the first branch is repeatedly ready, it will be
repeatedly selected, and the other branches will be starved.

By contrast, the |serve| aims to be fair.  It uses the same alt on each
iteration.  It remembers which branch was selected on the previous iteration,
and tests whether branches are ready starting from the following one (looping
round).
%
This means that if a particular branch is continuously ready, and the |serve|
performs enough iterations, then that branch will eventually be selected.  We
say that the |serve| is \emph{fair} to each branch.

%% Both the |serve| and the |repeat{alt(...)}| constructs evaluate each guard
%% expression~|g|$_i$ and each port expression |in|$_i$ on each iteration.

%%%%%

Here's the tagger again:
%
\begin{scala}
  serve( l =?=> { x => out!(0, x) } | r =?=> { x => out!(1, x) } )
\end{scala}
%
Note that this is fair to its two input ports: once one becomes ready, the
|serve| will receive from it after at most one communication on the other
port.
%
The |serve| loop terminates when either both |l| and~|r| are closed, or |out|
is closed. 

%%%%% \heading{About fairness}

Fairness crops up in a number of scenarios in concurrent programming.
%
A typical fairness property is that if a particular option is continually
logically possible, then it eventually happens.  Fairness for an alt
construct means that if a particular branch is continually ready, and the
alt performs enough iterations, then eventually that branch is selected.

Note that ``fair'' doesn't necessarily mean equal shares: a construct that
chooses option~$A$ 99\% of the time, and chooses option~$B$ 1\% of the time is
fair despite not giving equal shares.

Fairness is psychologically attractive: certainly, being fair to other people
in everyday life is a good thing.  However, it's not always appropriate in a
concurrent program.  In some scenarios, achieving fairness has a performance
overhead.  And sometimes fairness can be achieved only by a more complicated
program.  You should consider whether or not fairness is desirable.  Often you
can achieve higher throughput, and a simpler program, without fairness.
