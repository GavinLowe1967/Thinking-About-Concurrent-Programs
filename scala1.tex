\section{Core language features}
\label{sec:scala-core}

As a first example, below is a simple program for
calculating factorials. 
%
%\begin{figure}
\begin{scala}
/** A program for calculating factorials. */
object Factorial{
  /** The factorial of £n£.  Pre: £n $\ge 0$£. */
  def fact(n: Int): Int = {
    require(n >= 0, s"Illegal argument $n for fact")
    var x = 1 // Invariant: £$\sm x = \sm i !$£ at the end of each iteration.
    for(i <- 1 to n) x = x*i
    x
  }

  def main(args: Array[String]) = {
    val n = args(0).toInt; println(fact(n))
  } 
}
\end{scala}
%% \caption{A simple factorial program.}
%% \label{fig:factorial}
%% \end{figure}

%%%%%

Most of the work is done by the function |fact| (Scala
box~\ref{sb:functions}): this takes an argument~|n| which is an |Int| (Scala
box~\ref{sb:types}), and returns the factorial of~|n|, also an |Int|.

%\afterpage{\clearpage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{scalaBox}{Functions}
\label{sb:functions}
In Scala, functions are introduced using the keyword \SCALA{def} (short for
\emph{definition}).  Each parameter (or argument) of the function is given a
type using a single colon, e.g.~\SCALA{a: A}.  Likewise the type of the result
of the function can be given using a colon.  For example
\begin{scala}
  def func(a: A, b: B, c: C): T = ...
\end{scala}
introduces a function called |func| that takes three parameters |a|, |b|,
and~|c|, of types~|A|, |B|, and |C|, respectively, and returns a result of
type~|T|.  The body of the function appears on the right-hand side of the
``|=|''.  If the body consists of more than a single command or expression,
then it should be surrounded by curly brackets.

The return type of a function is often optional.  However, it is necessary for
a recursive function.  Even when it is not necessary, it is often a good idea
to include it, to help document the function.

If the body of the function ends with an expression, the result of the
function is the value of that expression: no explicit |return| is necessary.
\end{scalaBox}

%%%%%

\begin{scalaBox}{Value types}
\label{sb:types}
Scala has several primitive value types.  In this book we use the following.
\begin{description}
\item[{\scalashape Int}:] 32-bit integers, holding values in the range
  $\interval{-2^{31}}{2^{31}}$; 

\item[{\scalashape Long}:] 64-bit integers, holding values in the range
  $\interval{-2^{63}}{2^{63}}$; 

\item[{\scalashape Double}:] 64-bit floating-point numbers;

\item[{\scalashape Boolean}:] booleans, with two values, |true| and |false|;

\item[{\scalashape Unit}:] the unit type, containing a single value~|()|
  called the unit value.
\end{description}
% I don't think we use Float or Char.
\end{scalaBox}

%%%%%


The function starts by checking the precondition~$\sm n \ge 0$ (Scala
box~\ref{sb:assertions}).  It then declares a variable~|x| and initialises it
to~1 (Scala box~\ref{sb:variables}).  It next uses a |for| loop (Scala
box~\ref{sb:for-loop}), where the variable~|i| takes each value in the range
from |1| to |n|, inclusive, in turn (Scala box~\ref{sb:ranges}).  For each
such~|i|, the code multiplies |x| by~|i| (Scala box~\ref{sb:assignment}).
Finally, the function returns the value of~|x| (Scala
box~\ref{sb:functions}). The body of the function consists of the sequential
composition of these four lines (Scala box~\ref{sb:seq-comp}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{scalaBox}{Assertions}
\label{sb:assertions}
The command |assert(|$test$|)| evaluates the boolean expression $test$, and
gives an error if it is false.  The command |assert(|$test$|, |$msg$|)| is
similar, except it also displays the string $msg$ if $test$ is false.
Assertions are useful to catch errors in your code.  They are also useful to
document code, illustrating a property that you believe to be true at a
particular point.

The commands |require(|$test$|)| and |require(|$test$|, |$msg$|)| are
similar, except conventionally they are used to check preconditions of
functions.  Such statements are useful to catch when a function has been
erroneously called with its precondition not satisfied.  They are also useful
to document the code, stating assumptions.
\end{scalaBox}


%%%%%

\begin{scalaBox}{Variables}
\label{sb:variables}
\emph{Variables} are declared in Scala using the keyword |var|.  For example
\begin{scala}
  var x = 1
\end{scala}
introduces a new variable |x| and initialises it to~|1|.

Every variable in Scala has a \emph{type}, defining the range of values that
it can take.  The Scala compiler normally infers the type of a variable from
the way that it is initialised.  For example, the variable~|x|, above, has
type |Int|, the normal type for integers (whole numbers).  The Scala compiler
infers this type because |x| is initialised to~|1|, which has this type.  %% In
%% Scala (and most other languages), these |Int|s can hold only numbers in a
%% limited range, from $-2^{31}$ (inclusive) to $+2^{31}$ (exclusive).
%
%Scala box~\ref{sb:assignment} describes how variables are updated. 
\end{scalaBox}

%%%%%

\begin{scalaBox}{\SCALAKW{for} loops}
\label{sb:for-loop}
The |for| loop \SCALA{for(x <- xs) body} executes \SCALA{body}, where \SCALA{x}
takes each value in the sequence~\SCALA{xs} in turn.
\end{scalaBox}

%%%%%

\begin{scalaBox}{Ranges}
\label{sb:ranges}
\SCALA{a until b} creates the sequence of numbers from~\SCALA{a}
to~\SCALA{b-1}, inclusive.
% , which we sometimes write as $\interval{\sm a}{\sm b}$.
Similarly, \SCALA{a to b} creates the sequence of numbers from~\SCALA{a}
to~\SCALA{b}, inclusive.
\end{scalaBox}

%%%%%

\begin{scalaBox}{Assignment}
\label{sb:assignment}
Variables are updated using |=|.  For example
\begin{scala}
  x = x*i
\end{scala}
sets |x| to its previous value times~|i|.  
%
The assignment could also have been written as |x *= i|.  Likewise, an
assignment |x = x+1| could be written as |x += 1|.  Similar assignment
operators can be used with other infix operators; however, we prefer not to
over-use them.
\end{scalaBox}

%%%%%

\begin{scalaBox}{Sequential composition}
\label{sb:seq-comp}
Two commands can be executed one after the other by putting a semicolon
(``|;|'') between them; for example
\begin{scala}
  i = i+1; f = f*i
\end{scala}
Alternatively, they can be written on separate lines: the compiler
\emph{infers} a semicolon at the end of the line:
\begin{scala}
  i = i+1
  f = f*i
\end{scala}
\end{scalaBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{scalaBox}{Comments}
\label{sb:comments}
A one-line comment may be written in code by preceding it with ``|//|'':
\begin{scala}
  // This is a comment.
\end{scala}

A longer comment may be written
by placing it between ``{\scalastyle\rm /*}'' and ``{\scalastyle\rm */}''; it is
conventional to start each subsequent line with another 
``{\scalastyle\rm *}'':
\begin{scala}
  /* This is a comment that is too
   * long to fit on one line. */
\end{scala}

Scaladoc is a tool for extracting comments from a Scala program, and producing
corresponding HTML documentation.  Scaladoc uses comments that are written
between ``{\scalastyle\rm /**}'' and ``{\scalastyle\rm */}''; it is
conventional to start each subsequent line with another ``{\scalastyle\rm
  *}''.
%
%% There are good online tutorials describing Scaladoc syntax.  However, we will
%% mostly just give straightforward comments. 
\end{scalaBox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bigskip

\pagebreak[3]

The function is preceded by a comment, using Scaladoc format (Scala
box~\ref{sb:comments}), describing what the function does.  Internally, it
uses a comment to document an invariant of the loop.

\pagebreak[3]

The program is encapsulated in an object called |Factorial| (Scala
box~\ref{sb:objects}).  This has a |main| function (Scala box~\ref{sb:main})
which expects to receive a single argument on the command line.  It sets the
name~|n| to refer to this argument, converted to an |Int| (Scala
boxes~\ref{sb:arrays}, \ref{sb:val} and~\ref{sb:strings}).  It then calls
|fact|, instantiating its parameter with~|n|, and prints the result (Scala
box~\ref{sb:print}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{scalaBox}{Objects}
\label{sb:objects}
An object is defined using syntax
\begin{scala}
  object MyObject{ ... }
\end{scala}
%
The body (denoted ``|...|'' above) contains definitions, for example of
values, functions, types, and nested objects.  Typically, these constitute
some data and some operations on that data.

The definition defines a single object |MyObject|: this is sometimes called
the singleton pattern.

A field of an object can be accessed using the ``|.|'' operator,
e.g.~|MyObject.x|. 
\end{scalaBox}

%%%%%

\begin{scalaBox}{{\scalashape main} functions}
\label{sb:main}
Each program should contain a function with declaration
\begin{scala}
  def main(args: Array[String]) = ...
\end{scala}
This is  executed when the program is run.  The parameter |args| is
instantiated with any additional arguments provided on the command line.
\end{scalaBox}

%%%%%

\begin{scalaBox}{Arrays}
\label{sb:arrays}
If \SCALA{T} is a type then \SCALA{Array[T]} represents the type of arrays
that hold data of type~\SCALA{T}.  (This is an instance of parametric
polymorphism: see Scala box~\ref{sb:polymorphic}.)

Each array has a fixed size. The size of |a| can be obtained using the
expression |a.length|.

A new array of size~|n| can be created with, e.g.,
\begin{scala}
  val a = new Array[T](n)
\end{scala}

The \SCALA{i}th entry of array \SCALA{a} can be obtained using \SCALA{a(i)}.
(Note the round parentheses!)  The indexing is zero-based, i.e., if \SCALA{a}
is of size \SCALA{n}, then the elements are \SCALA{a(0),...,a(n-1)}.  This
indexing operation takes constant time.  

Arrays are \emph{mutable}.  The individual entries can be updated, e.g.
\begin{scala}
  a(i) = a(i) + 1
\end{scala}
\end{scalaBox}

%%%%%

\begin{scalaBox}{Named values}
\label{sb:val}
The Scala keyword |val| introduces a named value.  For example
\begin{scala}
  val f = fact(n)
\end{scala}
evaluates |fact(n)| and sets |f| to store the result.

Unlike variables introduced with |var|, values introduced with |val| can not
subsequently be changed; we say that they are \emph{immutable}.  Using |val|
rather than |var|, when appropriate, can make your program clearer: the reader
will understand that the value will not change.
\end{scalaBox}

%%%%%

\begin{scalaBox}{Strings}
\label{sb:strings}
Strings in Scala have type |String|.  They can  be defined by typing them
between double inverted commas, for example
\begin{scala}
  val hello = "Hello!"
\end{scala}

Strings can be concatenated together using ``|+|''. 

The operation |v.toString| converts value~|v| to a |String|.  The Scala compiler
provides a default implementation of |toString| for all values.  The
|toString| function is applied automatically when a |String| representation of
a value is required, for example within |println|.

Conversely, if |String|~|s| represents an |Int|, then it can be converted to
that |Int| using |s.toInt|.
\end{scalaBox}

%%%%%

\begin{scalaBox}{Standard printing functions}
\label{sb:print}
The standard function |print| prints its argument on the screen.
The function |println| is similar, except it also ends the line.
\end{scalaBox}

%%%%%
