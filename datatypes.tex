\chapter{Concurrent Datatypes}
\label{chap:datatypes}

\input{datatypes1} % concurrent total queue, using a server;
\input{datatypes2} % linearizability 
\input{datatypes3} % linearizability testing
\input{datatypes-partial-queue} % partial queue, including termination
\input{datatypes-graph-search} % breadth-first search.

%%%%%

\section{Summary}

In this chapter we have studied concurrent datatypes.  Such a concurrent
datatype should act much like a corresponding sequential datatype, but provide
thread-safe operations.  Different operation executions should appear to take
place in a one-at-a-time order, without interference, in an order compatible
with the calls and returns of the operations.

The implementer of the datatype needs to think about concurrency.  However
that concurrency is localised into a single object, so normally fairly easy to
get right.  By contrast, client code can mostly ignore the fact that the
datatype is being used concurrently.

We have seen examples based around concurrent queues.  Exercises ask you to
adapt these techniques to concurrent stacks.

A concurrent datatype can be either total or partial.  In a total datatype,
each operation can take place in any state.  This sometimes requires some
thought concerning the operation's interface, for example returning a special
value when a natural precondition isn't satisfied.  By contrast, in a partial
datatype, an operation blocks when its precondition does not hold.

The concept of linearization captures the correctness of a concurrent
datatype.  Operation executions should appear to take place in a one-at-a-time
order, each taking place between the call and return, and such that the
sequence of operation executions, and their return values, satisfies our
requirements, typically that they match a corresponding sequential datatype.

Testing for linearizability is fairly straightforward within SCL.  The tester
needs to define workers that perform and log operations on the concurrent
datatype, and needs to define how the corresponding operation behave on the
sequential specification object.  In particular, the framework allows the
tester to capture preconditions for partial operations. 

We illustrated the use of concurrent datatypes by implementing a graph search
that followed approximate breadth-first order.  We needed to adapt the
implementation of a partial queue so that it detects the termination case
where the queue is empty and all workers are attempting to dequeue.  The code
for each worker was then rather similar to that for the corresponding
sequential algorithm, although ensuring termination required a bit of work.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\exercises


\input{Exercises/serverSet} % concurrent set

\input{Exercises/serverStack} % Total stack

\input{Exercises/partialStack} % Partial stack

\input{Exercises/sudoku} % Concurrent DFS for sudoku (cf practical). 

% maximum in array
