\section{Example: graph search}

Many Computer Science applications involve searching in a graph (whether
explicitly or implicitly).  Examples include:
%
\begin{itemize}
\item Route planning, where the nodes of the graph are places, and the edges
  are roads between them;

\item Planning, where the nodes of the graph are intermediate stages towards
  some goal, and the edges are possible steps;

\item Puzzle solving, such as sudoku, where the nodes of the graph are partial
  solutions to the puzzle, and the edges correspond to steps of the puzzle;

\item Verification of some computer system, where the nodes of the graph are
  states that the system can reach, and the edges are transitions that the
  system can perform.  
\end{itemize}
%
Searches might aim to minimise some cost, or might aim to find a node with a
particular property.  Searches might use breadth-first search, depth-first
search, or some more specialised search algorithm such as Dijkstra's Algorithm
or the A$^*$ Algorithm.

In this section we will examine a concurrent algorithm to search a graph for a
node with a particular property, using approximate breadth-first search.
Exercise~\ref{ex:dfs} asks you to implement approximate concurrent
depth-first search.

We define a graph as an implementation of the trait |Graph[N]| in
Figure~\ref{fig:graph}.  The type parameter~|N| represents nodes.  The
function |succs(n)| gives the successors of node~|n|, i.e.~all nodes |n'| such
that there is an edge from |n| to |n'|.

%%%%%

\begin{figure}
\begin{scala}
/** A trait representing an unlabelled graph with nodes of type £N£. */
trait Graph[N]{
  /** The successors of node £n£. */
  def succs(n: N): List[N]
}

/** A trait representing a graph search problem in graph £g£. */
abstract class GraphSearch[N](g: Graph[N]){
  /** A path in the graph. */
  type Path = List[N]

  /** Try to find a path in £g£ from £start£ to a node that satisfies £isTarget£. */
  def apply(start: N, isTarget: N => Boolean): Option[Path]
}
\end{scala}
\caption{The traits {\scalashape Graph} and {\scalashape GraphSearch}.}
\label{fig:graph}
\end{figure}

%%%%%

The abstract class |GraphSearch| describes a graph search problem.  The class
takes a parameter~|g| representing the graph in which to search.  The function
|apply(start, isTarget)| searches in~|g|, starting at node~|start|, for a
target node that satisfies~|isTarget|.  If successful, it returns a result
|Some(p)| where |p| is a path from~|start| to the target node found; otherwise
it returns~|None|. 

\def\word#1{\emph{#1}}

To make things more concrete, the book website includes a solution to the
following word puzzle, invented by Charles Dodgson (also known as Lewis
Carroll).  Find a path of words linking two given words, where each word
differs from the previous in a single letter.  Dodgson used the example of
finding such a path linking \word{grass} to \word{green}, and gave the
solution \word{grass}, \word{crass}, \word{cress}, \word{tress}, \word{trees},
\word{frees}, \word{freed}, \word{greed}, \word{green}, although in fact there
are shorter solutions.  We can build a |Graph| to represent this puzzle, where
each node is a word (from some dictionary file), and with the successors of a
node being those that differ by one letter.  The |GraphSearch| then solves the
problem.

%%%%%

\begin{figure}
\begin{scala}
/** Sequential graph search implementation. */
class SeqGraphSearch[N](g: Graph[N]) extends GraphSearch[N](g){
  def apply(start: N, isTarget: N => Boolean): Option[Path] = {
    if(isTarget(start)) Some(List(start))
    else{
      val queue = new Queue[(N, Path)](); queue += ((start, List(start)))
      val seen = new HashSet[N]; seen.add(start)
      while(queue.nonEmpty){
        val (n, path) = queue.dequeue()
        for(n1 <- g.succs(n)){
          if(isTarget(n1)) return Some(path :+ n1)
          else if(seen.add(n1)) queue.enqueue((n1, path :+ n1))
        }
      }
      None
    }
  }
}
\end{scala}
\caption{A sequential implementation of breadth-first search.}
\label{fig:bfs-seq}
\end{figure}

%%%%%

Figure~\ref{fig:bfs-seq} gives a sequential implementation of breadth-first
search.  To deal with a corner-case, if the start node is also a target, it
immediately returns the singleton path.  Otherwise, it uses a queue |queue| to
store nodes that still need to be expanded: this provides the breadth-first
behaviour.  Each node in the queue is paired with the path that reached it, to
allow a successful path to be reproduced.  In addition, the code keeps track
of the set~|seen| of nodes seen previously, to avoid repeating work.

The code repeatedly removes a node~|n| and the corresponding path~|path| from
the queue, and consider each of its successors.  If a successor node~|n1| is a
target, we are done: the function returns the relevant path (|path :+ n1|
represents |path| with |n1| added at the end).  Otherwise, if the successor
node hasn't been seen previously, it is added to the queue with the relevant
extended path (the operation |seen.add(n1)| returns false if |n1| is already
in~|seen|).  If it gets to a state where the queue is empty, it has explored
all of the graph reachable from |start| without finding a target node, so it
returns |None|.

\begin{instruction}
Make sure you understand the sequential implementation of breadth-first search.
\end{instruction}

%%%%%

We now consider a concurrent algorithm.  Each worker thread  executes very
much as in the main loop of the sequential algorithm.

The workers share a concurrent queue, in particular a
|Terminating|\-|Partial|\-|Queue|.  If the graph has no reachable
target node, eventually the system will get into a state where the queue is
empty and all threads are attempting to dequeue, and so each |dequeue| will
return |None|: this will allow the system to terminate.

The workers also share a set of nodes that have already been seen.  It would
be a mistake to use a standard sequential set implementation, such as a
|HashSet| from the Scala API, since this is not thread-safe.  Instead, we need
a concurrent set.  We give the concurrent set the interface |ConcSet| in
Figure~\ref{fig:ConcSet}.  Exercise~\ref{ex:conc-set} asks you to provide an
implementation |ServerConcSet| of |ConcSet|, using a server thread.

\begin{figure}
\begin{scala}
trait ConcSet[A]{
  /** Add £x£ to this set.  Return £true£ if £x£ was not previously in the set. */
  def add(x: A): Boolean

  /** Shut down the set. */
  def shutdown(): Unit
}
\end{scala}
\caption{The interface for a simple concurrent set.}
\label{fig:ConcSet}
\end{figure}

We also assume that the |succs| method on the |Graph| object is thread-safe.
In most cases, this method will just perform reads, so there will be no race
conditions.  However, it is worth noting this requirement. 

If a path is found, we need to arrange for that path to be returned.  We need
to ensure the other threads terminate, and the queue is shut down.  However,
if two threads each find a path, we need to return just one of them: it would
be a mistake for each such thread to write its path into a shared variable, as
this would be a race.  Instead, we use a coordinator thread: if a worker
thread finds a path, it sends it to the coordinator on a channel~|pathFound|;
the coordinator then arranges for the rest of the system to terminate.

Figure~\ref{fig:graph-search-conc} gives the concurrent implementation.  The
implementation again treats the case that the start node is also a target node
as a special case. 


%%%%%

\begin{figure}
\begin{scala}
/** A class to search £g£ concurrently, using £numWorkers£ worker threads. */
class ConcGraphSearch[N](g: Graph[N], numWorkers: Int) 
    extends GraphSearch[N](g){
  /** Try to find a path in £g£ from £start£ to a node that satisfies £isTarget£. */
  def apply(start: N, isTarget: N => Boolean): Option[List[N]] = {
    if(isTarget(start)) Some(List(start))
    else{
      val queue = new TerminatingPartialQueue[(N, Path)](numWorkers)
      queue.enqueue((start, List(start)))
      val seen = new ServerConcSet[N]; seen.add(start)
      val pathFound = new SyncChan[Path] // To send solution to £controller£.
      var result: Option[Path] = None // Holds final result. 

      def worker = thread("worker"){
        var done = false
        repeat(!done){
          queue.dequeue() match{
            case Some((n, path)) =>
              for(n1 <- g.succs(n)){
                if(isTarget(n1)){ pathFound!(path :+ n1); done = true } 
                else if(seen.add(n1)) queue.enqueue((n1, path :+ n1))
              }
            case None => done = true
          }
        }
        pathFound.close() // Causes coordinator to close down.
      }

      def coordinator = thread("coordinator"){
        attempt{ result = Some(pathFound?()) }{ }
        queue.shutdown(); seen.shutdown(); pathFound.close()
      }

      val workers = || (for(_ <- 0 until numWorkers) yield worker)
      run(workers || coordinator)
      result
    }
  }
}
\end{scala}
\caption{The concurrent graph search algorithm.}
\label{fig:graph-search-conc}
\end{figure}

%%%%%

Each worker acts much like in the main loop of the sequential implementation,
although with a few differences.  If a worker finds a path, it sends it to the
controller, as described above.  If no path exists, the system reaches a state
where the queue is empty and all threads are trying to dequeue a node; each
call of |dequeue| then returns |None|, at which point the worker exits the
loop; it closes |pathFound| to signal to the coordinator that the system is
terminating.  It is also possible that the call of |dequeue| throws a |Closed|
exception, if another thread has found a solution, and the queue has been
shutdown; the |repeat| construct catches this exception.

If the controller receives a path from a worker, it writes it to the variable
|result|, which is subsequently returned.  However, if no path exists,
|pathFound| is closed, as described above; the |attempt| construct catches the
resulting |Closed| exception.  The controller then shuts down the queue: if it
did indeed receive a path, this will cause the other workers to terminate.  It
also shuts down the |seen| set, to allow its server to terminate.  Finally, it
closes |pathFound|: this is necessary in the case that a second worker thread
has found a solution and it trying to sent it to the controller. 

Finally, the workers and the controller are run in parallel; when the system
terminates, the value in |result| is returned. 

\begin{instruction}
Study the details of the implementation.
\end{instruction}

It is worth emphasising that the use of concurrent datatypes has simplified
the implementation.  Most of the concurrency is dealt with inside those
datatypes.  As a result, much of the code is similar to as in the sequential
case.  However, dealing with termination is an exception, for which we had to
come up with a suitable strategy: most of the complexity of dealing with
termination comes from the fact that there are two different ways
in which the search can terminate, corresponding to successful and
unsuccessful searches. 

The implementation doesn't quite achieve breadth-first search.  If a thread is
delayed, deeper nodes might be explored while a node from an earlier ply is
being expanded.  This might mean that the path that is found isn't the
shortest.  In many cases, this won't matter much.  If true breadth-first
behaviour is needed, the threads can performs a global synchronisation at the
end of each ply.

The implementation can be seen as a case of the bag-of-tasks with replacement
pattern.  Each node in the bag (the queue) represents the task of expanding
that node: this may lead to additional tasks being added to the bag.

