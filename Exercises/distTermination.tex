\begin{question}
Consider a system constructed from $N$ similar threads, with identities
$0, \ldots, N-1$.  Each thread can send messages to any other thread, on
synchronous channels.

Each thread is either \emph{active} or \emph{passive}.  When a thread is
passive, it simply waits to receive a message, at which point it becomes
active.  When a thread is active, it can send messages to any other
threads, but may eventually become passive.

The aim of this question is to consider a technique for determining whether
all the threads are passive, in which case the system can terminate.

\begin{enumerate}
\item Consider the following scheme.  Thread~0, when it is passive, sends a
token to thread~1, containing a boolean value, initially $true$.  Each
thread~$k$, when it receives a token of this form, sends a similar token to
thread~$(k+1) \bmod N$, so the token circulates, as if the threads are
arranged in a ring; note, though that other messages don't need to follow the
ring.  Thread~$k$ sets the value in the token to be $false$ if it is active,
or passes on the value it receives if it is passive; in each case, the thread
retains its previous status (active or passive).  When the token returns to
thread~0, if its value is $true$, it assumes that all threads are passive,
so sends a message to all threads telling them to terminate.

Explain why this scheme does \emph{not} achieve the desired goal.

%%%%%

\item
Describe how to adapt this scheme so that it does achieve the desired goal.
Explain why your scheme works.  

What safety and liveness properties does your scheme achieve?  Here, a safety
property should say that threads terminate only under appropriate conditions.
A liveness property should say that threads do indeed terminate under
appropriate circumstances.
% Make clear what (safety and liveness) properties your scheme achieves.

%%%%%

\item
Now suppose the normal messages do follow the ring topology.  Describe how to
adapt the scheme so that it achieves the desired goal. 

% \item
% Does it make a difference if the channels are asynchronous (i.e.~buffered)? 
\end{enumerate}
\end{question}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{answerI}
\begin{enumerate}
\item
Consider a ring of four threads, with thread~3 initially active.  Suppose
the token circulates to thread~2, so the boolean is still $true$.  Then
suppose thread~3 sends a message to thread~1 and becomes passive, but
thread~1 remains active.  Then the token is passed on to thread~3, then
back to thread~0, with the boolean still $true$.  Hence thread~0 assumes all
threads are passive, even though thread~1 is active.

%%%%%

\item Arrange for the token to go round the ring \emph{twice} (with some field
indicating whether it is on its first or second circuit).  On the second
circuit, each thread sets the boolean to be $false$ if it has been active at
any time since it saw the token the first time.

Consider the time~$t$ at which the token first returns to thread~0.  If any
thread is active at time~$t$, then it will subsequently set the boolean to
$false$.  Hence, if the value ends up $true$, then all threads were passive at
time~$t$, and so all remain passive subsequently; thus termination is correct
in this case.  This is a safety property: the system terminates only if it is
correct to do so.

It is possible for all the threads to become passive while the token is
circulating, but after at least one has seen it for the first time, in which
case the scheme does not lead to overall termination.  However, if
all are passive when the token starts circulating for the first time, then
termination will result.  This is a liveness property: the system does
terminate, under the stated conditions.

%%%%%

\item Arrange for the termination messages and the data messages to go round
the ring in the same direction.  Sending the token only once round the ring is
now sufficient: thread~0 can choose to terminate provided the boolean comes
back as $true$ and it has been continually passive since initiating the token.
The following property is invariant: if thread~0 remains passive, and the
boolean in the token is still $true$, then all threads between~0 and the
current token-holder are passive.

\emph{Alternatively} send the termination messages round the ring in the
\emph{opposite} direction, i.e.~node~$i$ sends the termination token to
node ${(i-1)} \bmod N$.   The following property is invariant: if thread~$i$
sends the token with value $true$, then all threads in the range $[i ..
N-1) \union \set{0}$ are passive.
\end{enumerate}
\end{answerI}
