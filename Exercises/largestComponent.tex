\begin{question}
This question considers another problem in image processing.  We can represent
an image by a two-dimensional array of |Int|s, where each entry represents the
colour of a single pixel.  For the purposes of this question, we consider two
pixels to be neighbours if they are horizontally or vertically (but not
diagonally) adjacent.  A set of pixels forms a \emph{connected component} if
it is possible to move between any two pixels in the set only by moving
neighbour-to-neighbour, with all those pixels having the same colour.  We want
to find the largest connected component.
% all of whose pixels are the same colour.  
For example, in the image in Figure~\ref{fig:image} (left), the largest
connected component contains ten pixels, all with ``colour''~0, and including
the pixel in the top-left corner.

%%%%%

\begin{figure}
\[
\begin{array}{cccccc}
0 & 1 & 0 & 2 & 2 & 3 \\
0 & 0 & 0 & 2 & 3 & 0 \\
1 & 0 & 0 & 3 & 3 & 1 \\
0 & 1 & 0 & 2 & 2 & 1 \\
0 & 1 & 0 & 0 & 1 & 1
\end{array}
\qquad\qquad
\begin{array}{cccccc}
(0,0) & (0,1) & (0,0) & (0,3) & (0,3) & (0,5) \\
(0,0) & (0,0) & (0,0) & (0,3) & (1,4) & (1,5) \\
(2,0) & (0,0) & (0,0) & (1,4) & (1,4) & (2,5) \\
(3,0) & (3,1) & (0,0) & (3,3) & (3,3) & (2,5) \\
(3,0) & (3,1) & (0,0) & (0,0) & (2,5) & (2,5)
\end{array}
\]
\caption{An example image (left), and its index array (right).}
\label{fig:image}
\end{figure}

%%%%%

Here is an outline of an algorithm to find  the largest connected
component.  
%
\begin{description}
\item[Stage 1.] Create an array of the same size as the image, where each
  entry is initialised to its own coordinates (row number, column number).  We
  call this an \emph{index array}, and each entry an \emph{index}.  Then
  repeatedly replace each entry in the index array by the
  smallest\footnote{Say using the lexicographic ordering.  An import of
    {\scalashape scala.math.Ordering.Implicits.\_} defines operators such as
    $<$ to be the lexicographic ordering over tuples.} of its current value
  and its neighbours of the same colour: the function |smallestNeighbourIndex|
  in Figure~\ref{fig:largestComponentCode} calculates such a smallest index.
  Repeat this until no further progress is made.  At the end of this stage,
  each entry in the index array will give the smallest index of the pixels in
  the corresponding connected component.  Figure~\ref{fig:image} (right) gives
  the index array for the example image.

\item[Stage 2.] Find the index that appears most often in the index array, and
  the number of times it appears.  In a sequential setting, this could be done
  by iterating over the index array, using a |Map[Index, Int]| to keep track
  of the number of occurrences of each index.
  %% For consideration of efficiency, you can assume
  %% that the number of connected components is small compared to the number of
  %% pixels.
  %% This can be done by flattening the
  %% array into a one-dimensional array, sorting it, and then scanning through
  %% it. 
\end{description}

Your task is to implement a concurrent version of this algorithm using |p|
worker threads, following the above outline.
Figure~\ref{fig:largestComponentCode} gives some supporting code.

%%%%%

\begin{figure}[t]
\begin{scala}
class LargestComponent(image: Array[Array[Int]], p: Int){
  val Height = image.length; require(Height > 0)
  val Width = image(0).length; require(image.forall(_.length == Width))

  /** An index, giving the coordinates of a value. */
  type Index = (Int,Int)

  /** An array of £Index£es. */
  type IndexArray = Array[Array[Index]]

  import scala.math.Ordering.Implicits._  
  // Defines "<", etc., as lexicographic order over £Index£.

  /** The smallest index (in £indexes£) of £(r,c)£ and its same£-£colour neighbours. */
  private def smallestNeighbourIndex(indexes: IndexArray, r: Int, c: Int): Index = {
    var minIx = indexes(r)(c)
    for((r1,c1) <- List((r-1,c), (r+1,c), (r,c-1), (r,c+1)))
      if(r1 >= 0 && r1 < Height && c1 >= 0 && c1 < Width && 
          image(r)(c) == image(r1)(c1) && indexes(r1)(c1) < minIx)
        minIx = indexes(r1)(c1)
    minIx
  }

  /** The index of the largest component, and its size. */
  def apply(): (Index, Int) = ...
}
\end{scala}
\caption{Code for the largest connected component problem}
\label{fig:largestComponentCode}
\end{figure}

%%%%%

In stage~1, the worker
threads should cooperate together to calculate the index array, with each
worker responsible for some of the entries.  In stage~2, threads should
cooperate together to find the most common index.  Each thread should be
responsible for counting the number of times different indexes appear in part
of the index array; and then they should cooperate together to find the most
common index overall.  Ideally, the  latter sub-stage should run in time
$O(K \times \log \sm p)$, where $K$ is the number of distinct indexes.
\end{question}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{answerI}
My code is below.  

Stage 1 proceeds in rounds.  Each thread is responsible for some of the rows.
The threads use two |IndexArray|s, corresponding to the |Index|es calculated
on the previous round and the current round; the roles are swapped at the end
of each round.  A combining barrier is used to coordinate and to decide
termination.

In state 2, each worker directly counts the entries in its segment.  There are
a number of ways to do this.  My code makes use of a map recording the current
count.  This is then converted into a list of |Index|es and their counts,
ordered by |Index| (type |IndexCount|).

Then the workers use a combining barrier to merge the workers' counts
together, making use of the helper function |merge| that merges two such
lists.  Finally, worker~0 finds the index with the largest count, and write it
into the |result| variable, which is subsequently returned.  Arguably, we
don't need the full functionality of a combining barrier here: since only
worker~0 needs the final result, we could just use a heap to merge the counts
upwards.

It is also possible to perform the second sub-stage using the pattern of
prefix sums from the body of the chapter.  But this requires a barrier
synchronisation on each round, so is  $O(K \times (\log \sm p)^2)$.

%%%%%


\begin{scala}
class LargestComponent(image: Array[Array[Int]], p: Int){
  ... // Code from question omitted. 

  /** Combining barrier, used in stage 1. */
  private val barrier1 = new OrBarrier(p)

  /** Variable that holds the final result. */
  private var result: (Index, Int) = null

  /** Arrays that hold the indexes on alternate rounds. */
  private val indexes0, indexes1 = Array.ofDim[Index](Height,Width)

  /** A £List£ representing a count of £Index£es.  Each entry gives an £Index£ and a
    * count for it.  The list is ordered by £Index£es. */
  private type IndexCount = List[(Index,Int)]

  /** Merge two £IndexCount£ lists. */
  private def merge(counts1: IndexCount, counts2: IndexCount): IndexCount = {
    var cs1 = counts1; var cs2 = counts2
    val result = new scala.collection.mutable.ArrayBuffer[(Index,Int)]()
    while(cs1.nonEmpty && cs2.nonEmpty){
      val (ix1,c1) = cs1.head; val (ix2,c2) = cs2.head
      if(ix1 < ix2){ result += ((ix1, c1)); cs1 = cs1.tail }
      else if(ix1 == ix2){ 
        result += ((ix1, c1+c2)); cs1 = cs1.tail; cs2 = cs2.tail 
      }
      else{ result += ((ix2, c2)); cs2 = cs2.tail }
    }
    cs1.foreach(result += _); cs2.foreach(result += _)
    result.toList
  }

  /** Combining barrier for stage 2. */
  private val barrier2 = new CombiningBarrier(p, merge)

  /** A worker. */
  private def worker(id: Int) = thread("worker"+id){
    // This worker is responsible for rows £[start..end)£.
    val start = id*Height/p; val end = (id+1)*Height/p
    // STAGE 1: calculate the index of each location.
    // Initialise share of the indexes in £indexes0£.
    for(r <- start until end; c <- 0 until Width) indexes0(r)(c) = (r,c)
    barrier1.sync(id, false) // Dummy argument.
    var lastIndexes = indexes0; var theseIndexes = indexes1; var done = false

    while(!done){
      var change = false // Have we seen a change on this round?
      // Update my share of £theseIndexes£ based on £lastIndexes£
      for(r <- start until end; c <- 0 until Width){
        // Find minimum index between £(r,c)£ and its neighbours
        val minIx = smallestNeighbourIndex(lastIndexes, r, c)
        theseIndexes(r)(c) = minIx
        if(minIx != lastIndexes(r)(c)) change = true
      }
      // Synchronise with others; set £done = true£ if no thread saw any change.
      done = ! barrier.sync(id, change)
      // Swap £theseIndexes£ and £lastIndexes£ for the next round.
      if(!done){ val t = theseIndexes; theseIndexes = lastIndexes; lastIndexes = t }
    } // End of £while(!done)£.

    // STAGE 2: collectively count the number in each component.
    // Build up counts for rows £[start..end)£ in a map.
    val map = new scala.collection.mutable.HashMap[Index,Int]
    for(r <- start until end; c <- 0 until Width){
      val ix = theseIndexes(r)(c)
      map.get(ix) match{
        case Some(n) => map += ix -> (n+1)
        case None => map += ix -> 1
      }
    }
    var myCounts = map.iterator.toList.sorted
    // Merge the workers' £myCounts£ arrays.
    val allCounts = barrier2.sync(id, myCounts)
    // £worker(0)£ writes final result to £result£ variable.
    if(id == 0) result = allCounts.maxBy(_._2)
  } // End of £worker£.


  /** Find the size of the largest connected component using £p£ workers. */
  def apply(): (Index, Int) = {
    run(|| (for(i <- 0 until p) yield worker(i)))
    result
  }
}
\end{scala}
\end{answerI}
