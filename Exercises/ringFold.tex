\begin{question}
\label{ex:ringFold}
Suppose $n$ threads are connected in a ring.  Each thread~$i$ (for $i = 0,
\ldots, n-1$) initially holds a value~$x_i: T$.  Write a concurrent program so
that each thread ends up in possession of the value
\[\mstyle
f(f(f(\ldots f(x_0, x_1), x_2) \ldots ), x_{n-1}),
\]
for some given function $f$.
%% ; or using functional programming notation:
%% \[
%% \mathrm{foldl1}~f~ List(x_0, x_1, \ldots, x_{n-1})
%% \]
Give your program the following signature (where $\sm{xs}(i) = x_i$, for
each~$i$):
%
\begin{mysamepage}
\begin{scala}
class RingFold[T](xs: Array[T], f: (T,T) => T, outs: Array[SyncChan[T]]){  
  private val n = xs.length
  require(n >= 2 && outs.length == n)

  def apply(): ThreadGroup = ...
}
\end{scala}
\end{mysamepage}
%
\noindent
Or, if you use buffered channels of type |BuffChan|, you will need to write 
\begin{scala}
class RingFold1[T: scala.reflect.ClassTag] ...
\end{scala}
%
Each thread should output its final result on the appropriate |outs| channel.
You should state properties that hold at key points of your program, for
example concerning the values passed on channels.

Test your code. 

What property of~$f$ will allow a different program that achieves the same
goal?  Explain your answer, and outline how this can be achieved.  (A full
implementation is not necessary.)
\end{question}

%%%%%

\begin{answerI}
This is a polymorphic generalisation of the sum example from the body of the
book. 

We write $x_i$ for $\sm{xs}(i)$.  Define
\[\mstyle
\mathrm{combine}~f~ \seq{x_0, x_1, x_2, \ldots, x_k} = 
  f(f(f(\ldots f(x_0, x_1), x_2) \ldots ), x_k),
\]
i.e.,~those elements combined together using~$f$.  

My code is below.  A single token is passed twice round the ring.  On the
first cycle, the desired value is built up.  The node with identity~$me$ sends
$\mathrm{combine}~f~\seq{x_0, x_1, x_2, \ldots, x_{me}}$.  This is easily
proven by induction, and is justified by the comments in the code.  The
comment concerning |y| holds because the value received was sent by
node~$\sm{me}-1$, which is running the same protocol.  Hence
node~0 receives back the desired result, which then gets past round the ring
on the second cycle.
%
\begin{scala}
class RingFold[T](xs: Array[T], f: (T,T) => T, outs: Array[SyncChan[T]]){
  private val n = xs.length
  require(n >= 2 && outs.length == n)

  /** The channels connecting nodes, indexed by the recipient's identity:
    * node(i) receives on chans(i) and sends on chans((i+1)%n). */
  private val chans = Array.fill(n)(new SyncChan[T]) 

  /** A single node. */
  private def node[T](me: Int) = thread{
    val left = chans(me); val right = chans((me+1)%n)
    val out = outs(me); val x = xs(me)
    if(me == 0){
      right!x // Start things going.
      val result = left?(); right!result// Receive final result and pass it on.
      out!result
    }
    else{
      val y = left?() // = £combine f $\seq{x_0, \ldots, x_{\ss{me}-1}}$£.
      right!f(y,x) // = £combine f $\seq{x_0, \ldots, x_{\ss{me}}}$£.
      val result = left?()          // Receive final result.
      if(me != n-1) right!result    // Pass it on if I'm not the last node.
      out!result
    }
  }  

  /** The complete ring. */
  def apply(): ThreadGroup = || (for(i <- 0 until n) yield node(i))
}
\end{scala}



%% \begin{scala}
%% /** A ring of node threads.  The ith node holds the value xs(i).  Each ends
%%   * up with the value of foldleft f xs.  Node i outputs its final value on
%%   * outs(i).  */
%% class RingFold[T](xs: Array[T], f: (T,T) => T, outs: Array[Chan[T]]){
%%   private val n = xs.length
%%   require(n >= 2 && outs.length == n)

%%   /** The channels connecting nodes, indexed by the recipient's identity:
%%     * node(i) receives on chans(i) and sends on chans((i+1)%n). */
%%   private val chans = Array.fill(n)(OneOne[T]) 

%%   /** A single node. */
%%   private def node[T](me: Int) = proc{
%%     val left = chans(me); val right = chans((me+1)%n)
%%     val out = outs(me); val x = xs(me)
%%     if(me == 0){
%%       right!x // Start things going; = foldl1 f xs[0..me]
%%       val result = left?() // Receive final result; = foldl1 f xs
%%       right!result  // Pass it on
%%       left?()       // Receive it back at the end
%%       out!result
%%     }
%%     else{
%%       val y = left?() // y = foldl1 f xs[0..me-1]
%%       right!f(y,x)    // = foldl1 f xs[0..me]
%%       val result = left?(); right!result // Receive final result and pass it on
%%       out!result
%%     }
%%   }  

%%   /** The complete ring. */
%%   def apply(): PROC = || (for(i <- 0 until n) yield node(i))
%% }
%% \end{scala}

The program can be tested by picking a suitable function~|f|, choosing random
values for |xs|, calculating the expected value sequentially, and then running
the ring in parallel with a thread that receives the values on the |out|
channels and checks that they are as expected.


%% Most of my testing code is below.  (This also works with the solution for the
%% final part of the program.)  A subsidiary |checker| thread receives all the
%% final values, and checks that they are as expected.
%% %
%% \begin{scala}
%%   /** A thread that expects to receive expected on each channel in chans, and
%%     * throws an exception if an incorrect value is received. */
%%   def checker(chans: Array[SyncChan[Int]], expected: Int) = thread{
%%     for(chan <- chans){ val res = chan?(); assert(res == expected) }
%%   }

%%   /** A single test of either RingFold or RingFold1, using random values.
%%     * @param assoc use RingFold1 if true */
%%   def doTest(assoc: Boolean) = {
%%     val n = 2+Random.nextInt(20)
%%     val xs = Array.fill(n)(Random.nextInt(100))
%%     val outs = Array.fill(n)(new SyncChan[Int])
%%     def f(x: Int, y: Int) = if(assoc) x+y else 2*x+y
%%     val rf =
%%       // Note: abbreviating ".apply" to "()" requires the ClassTag
%%       if(assoc) new RingFold1[Int](xs, f, outs).apply()
%%       else new RingFold[Int](xs, f, outs)()
%%     run(rf || checker(outs, xs.foldLeft(0)(f)))
%%   }
%% \end{scala}

%% %  
%% \begin{scala}
%%   /** A process that expects to receive expected on each channel in chans, and
%%     * throws an exception if an incorrect value is received. */
%%   def checker(chans: Array[Chan[Int]], expected: Int) = proc{
%%     for(chan <- chans){ val res = chan?(); assert(res == expected) }
%%   }

%%   /** A single test of either RingFold or RingFold1, using random values.
%%     * @param assoc use RingFold1 if true */
%%   def doTest(assoc: Boolean) = {
%%     val n = 2+Random.nextInt(20)
%%     val xs = Array.fill(n)(Random.nextInt(100))
%%     val outs = Array.fill(n)(OneOne[Int])
%%     def f(x: Int, y: Int) = if(assoc) x+y else 2*x+y
%%     val rf: PROC =
%%       if(assoc) new RingFold1[Int](xs, f, outs)()
%%       else new RingFold[Int](xs, f, outs)()
%%     (rf || checker(outs, xs.foldLeft(0)(f)))()
%%   }
%% \end{scala}

If $f$ is associative and commutative, then a different protocol is possible.
On the first round, each node sends its initial value to its neighbour.  On
each subsequent round, each node applies $f$ to the value it receives and its
own initial value, and passes the result on.  On each round~$r$ (counting
from~0), each node~$me$ sends the value
\[\mstyle
\mathrm{combine}~f~ \seq{x_{me-r}, x_{me-r+1}, x_{me-r+2} \ldots, x_{me}}
\]
%% xs[me-r..me] =
%%   f(f(f(\ldots f(x_{me-r}, x_{me-r+1}), x_{me-r+2}) \ldots ), x_{me}),
%% \]
to node~$me+1$, where all indices are interpreted mod $n$.  The code has an
invariant that at the start of round~$r$, the variable |y| holds the above value.
%
After $\sm n-1$ rounds, each node~$me$ has the value
\[\mstyle
\mathrm{combine}~f~ \seq{x_{me-(n-1)}, x_{me-r+1}, x_{me-r+2} \ldots, x_{me}},
\]
which equals  the desired final value by the assumption that $f$ is
associative and commutative.

The changes from the previous code are below.  The channels need to be
buffered to avoid deadlocks, obviously.
%
\begin{scala}
  private val chans = Array.fill(n)(new OnePlaceBuffChan[T]) 

  private def node[T](me: Int) = thread{
    val left = chans(me); val right = chans((me+1)%n)
    val out = outs(me); val x = xs(me); var y = x
    for(r <- 0 until n-1){
      right!y         // = £combine f $\seq{x_{\ss{me}-\ss r}, \ldots, x_{\ss{me}}}$£.
      val z = left?() // = £combine f $\seq{x_{\ss{me}-1-\ss r}, \ldots, x_{\ss{me}-1}}$£.
      y = f(z, x)     // = £combine f $\seq{x_{\ss{me}-\ss r+1}, \ldots, x_{\ss{me}}}$£.
    }
    // £y = combine f $\seq{x_{\ss{me}-(\ss n-1)}, \ldots, x_{\ss{me}}}$ = combine f xs£, since £f£ is
    // associative and commutative.
    out!y
  }  
\end{scala}
%
%% \begin{scala}
%%   /** The channels connecting nodes, indexed by the recipient's identity:
%%     * node(i) receives on chans(i) and sends on chans((i+1)%n).  The channels
%%     * need to be buffered. */
%%   private val chans = Array.fill(n)(OneOneBuf[T](1)) 

%%   /** A single node. */
%%   private def node[T](me: Int) = proc{
%%     val left = chans(me); val right = chans((me+1)%n)
%%     val out = outs(me); val x = xs(me); var y = x
%%     // Inv: at the start of round r, y = foldl1 f xs[me-r..me], where the indices
%%     // are interpreted mod n. 
%%     for(r <- 0 until n-1){
%%       right!y         // = foldl1 f xs[me-r..me]
%%       val z = left?() // = foldl1 f xs[me-1-r..me-1]
%%       y = f(z, x)     // = foldl1 f xs[me-(r+1)..me], maintaining invariant
%%     }
%%     // y = foldl1 f xs[me-(n-1)..me] = foldl1 f xs since f is AC.
%%     out!y
%%   }  
%% \end{scala}
%
The comment concerning |z| is justified by the fact that this value was sent
by node~|me-1|, which is running the same protocol, and must have sent this
value on its round |r| (since the channels are FIFO). 
\end{answerI}
