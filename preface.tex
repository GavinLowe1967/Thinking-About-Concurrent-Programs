\chapter*{Preface}
\addcontentsline{toc}{section}{Preface}
\markboth{Preface}{} % Else it says "list of Scala boxes!"

A concurrent program is a program with two or more threads of control that
cooperate together for some purpose.  Each has its own state.  The threads of
control might run in parallel, i.e.~at the same time, on separate hardware; or
they might share hardware, with execution interleaved between them.

There are several reasons why we might want to write a concurrent program.  It
might run faster.  It might provide a better way of structuring a large
program.  Or it might allows us to use hardware or services that are
physically distributed.

However, using concurrency introduces difficulties beyond those present with
sequential programs.  In a poorly designed concurrent program, different
threads might interfere with one another, leading to logical errors that are
hard to track down.  Instead, we need reliable techniques to produce a correct
concurrent program that coordinates threads correctly.  The aim
of this book is to explore and understand such techniques.

\framebox{Overview:} message passing, monitors, semaphores. 

This book will assume that the reader has some programming experience,
including a basic understanding of object-oriented programming.  We will use
Scala as our programming language, because it suits our purposes well.  It has
a clean syntax, with intuitive semantics, backed up by an extensive
Application Programming Interface.

Appendix~\ref{app:scala} gives an overview of the parts of Scala that we use.
If you have used Scala before, or are an experienced programmer, you will
probably find that you can understand the code without reading the appendix,
or by just referring to relevant parts.  


In particular, we will use a library of concurrency primitives, \emph{Scala
  Concurrency Library (SCL)}, which I have developed.  This library allows us
to write concise yet clear concurrent programs, without the tedious
``boiler-plate'' code that would be necessary in some languages.

The book will also assume some familiarity with standard techniques for
reasoning about (sequential) programs, such as using pre- and post-conditions
to describe the intended effect of an operation, and loop invariants to
capture properties that are maintained by loops.  Many of these techniques map
across to concurrent programs.  But we will also need additional reasoning
techniques to deal with the challenges of concurrency.

%% \begin{instruction}
%% I will sometimes leave you to study some details of programs for yourself.  A
%% paragraph labelled with a triangle on the left, like this, is a nudge for you
%% to do that.
%% \end{instruction}

A major theme of the book will be modularisation.  Often, we will encapsulate
design decisions concerning concurrency within an object, which we will refer
to as a \emph{concurrent object}.  Operations on that object will be
thread-safe, i.e.,~different threads will not interfere with one another.
Client code can use that object without knowing how the concurrency is
implemented.  

A common example of a concurrent object is a concurrent datatype.  This
will correspond to a standard sequential datatype, such as a queue or a
mapping, but will be thread-safe.  Client code can use the concurrent datatype
much as they would a corresponding sequential datatype.

Of course, we will need to reason about concurrency when we implement the
concurrent object itself: but that reasoning will be local, which is much
easier than global reasoning.  Further, we can experiment with different
techniques for implementing the concurrent object.

Another major theme will be testing.  How can we test concurrent programs?
How can we perform unit testing on concurrent object?  Often this requires
different techniques from those for sequential programs or modules.

\framebox{Code availability}

\subsection*{How to read this book}

This book is not light reading.  The programs we develop will require careful
thought: but that thought will be rewarded with a better understanding, both
of the program itself, and of techniques for reasoning about programs.  You
should make sure that you understand each step in the programs.
%
\begin{instruction}
Paragraphs highlighted with a triangle on the left, like this one, indicate
some steps in the development that I will leave to you to check.  You should
take a few moments to carry out these checks.  Such checks will soon become
second nature.   
\end{instruction}
%
Most chapters  end with some exercises.  These exercises give you an
opportunity to practice the techniques discussed in the chapter: they are
designed to help you to improve your understanding.  Answers to exercises
labelled with ``$\dag$'' are in an appendix.

%% available from the book's webpage:
%% \begin{center}
%% \framebox{???}
%% % \url{https://www.stcatz.ox.ac.uk/thinkingaboutprograms/}
%% \end{center}
%% Answers to other exercises are available to bona fide instructors, from the
%% author.

%% Most of the code that appears in this book is also available from the book's
%% webpage.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection*{Acknowledgements}

A owe a debt of gratitude to Bernard Sufrin.  I first became interested in
concurrent programming when I taught some classes for a course on concurrent
programming that Bernard designed and lectured.  In subsequent years, we took
turns to run the course, building on one another's ideas.  Most of the
material in this book comes from that course, including several examples that
were originally Bernard's. 

In particular, the library SCL that we use in this book is heavily based on
Bernard's own library, CSO (Communicating Scala Objects): SCL inherits most of
its syntax concerning message passing from CSO.

Others: 
Vincent Cheval, 
Tom Gibson-Robinson, 
Karel Hruda, 
Jonathan Lawrence, 
\framebox{\ldots}
